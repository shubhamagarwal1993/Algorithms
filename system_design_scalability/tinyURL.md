# Shortening a URL to a tinyURL
- Uses are to save space when displayed
- Track user individual links to analyze users
- Hide original URLs

# Requirements:
## Creation, and User Account:
- Customer can specify a custom tiny URL or we generate a unique tinyURL for them
- Links will expire after a standard default timespan. Users should be able to specify the expiration time.

## Retrieval:
- When customer hits tinyURL, we redirect them to original link
- TinyURL should not be guessable (not predictable)
- Highly available, add popular links to cache

## Analytics:
- Keep track of any stats on the click / how many times a redirection happened

## Capacity:
- Read heavy system, assume 500 million new URLs per month

# Memory Management and Capacity calculations:
Letâ€™s assume 500 million new URLs per month, with 100 to 1 read / write ratio

## Traffic calculations:
Total redirections per month => 100 * 500 M => 50B

New tinyURLs generated per second => 500 M / (30 * 24 * 3600 seconds) => 200 URLs / second

Redirections per second => 100 * 200 URLs / sec => 20,000 / second
                        |--> comes from 100 times the write request as an assumption

## Database Memory calculations:
Assume average age of a tinyURL is 5 years.

- Total tinyURLs generated in 5 years => 500 M * 12 months * 5 years => 30B
- Average memory to store each tinyURL:
  - Each byte can store 1 character.
  - A tinyURL, full URL, and other details should be about 500 to 1000 characters.
  - That would be 1 Kilobyte (1000 Byte)
```
You should know this:
ASCII ranges from 0 to 127, and needs 1 byte to store a character.
Utf-8 ranges from 1 byte to 6 bytes depending on the character.

Total space for 30B url rows will be 30B * 1 Kb => 30 TB
```

## Caching Memory calculations:
Assume 20% URLs generate 80% traffic, and our cache stays warm for 1 day. Thus we need to cache 20% daily traffic

Total urls data per day => (200 URLs / second) * (24 hours * 3600 seconds) => 17280000 URLs
Total memory needed  => 17280000 URLs * 1KB => 17.280 GB

## Bandwidth calculations:
For incoming data => (URLs / second) * (size of each URL data blob)
                              => (200 URLs / sec) * (1KB)
                              => 200KB / second
For outgoing data => (100) * (For incoming data)
                             => (100) * 200 KB / second)
                             => 20 MB / second

# API Design:
- Use REST API endpoints so other services can use it.
- Create:
```
createURL(loginToken, originalURL, tinyURL=None, expiry=None)
loginToken: The user token to track for analytics, throttle max usage, or detect spamming
originalURL: The original URL to shorten. This cannot be empty, and can be checked if valid
tinyURL: A custom tinyURL that can be provided, else a random one will be generated by the system
expiry (seconds): A custom time to expire the link, by default it will be set to 5 years

Returns a success code with json containing all fields.
```
- Delete:
```
deleteURL(loginToken, originalURL=None, tinyURL=None)
loginToken: The user token to track for analytics, throttle max usage, or detect spamming
originalURL: The original URL can be used to delete all associated tinyURLs
tinyURL: The tinyURL to be deleted
Note: At least one field from originalURL or tinyURL must be provided for deletion

Returns a success code with no data
```

# Database Design:
```
Table 1: URLs
    Field can be originalURL, tinyURL, created, expiry, userID
Table 2: User data
    Id, first, last, email, password
```
- We can make another table just for originalURLs so they are not repeated if a lot of tinyURLs refer to the same originalURL. This will result in more joins or id lookups.
- We can use a noSQL or SQL database, both should be fine. This is a very relational type of data, and it might be easier to go with a SQL database.

# Algorithm:
By our calculations, we would have generated 30B tinyURLs in 5 years.
Let us fix our tinyURL to be 8 char long after the domain name, like http://tinyurl.com/jd93R2ew
Using base64 (a-z, A-Z, 0-9), we can get 62^8 => 281 Trillion keys, this should be more than enough.
To generate the 8 char long unique id, we can follow any of 2 methods
- Method 1: Generate from given originalURL
We can use the originalURL, userID, and a random salt to encode the given URL using md5 or sha1 and take the first 8 chars
  - Pros: This is done on the fly, and is quick.
  - Cons: There are possibilities of collision, we can retry 3 times with different salt, and return an error if there are 3 collisions.
- Method 2: Have a separate service to generate and keep a set of keys ready
We can have a standalone server, with a backup server to generate unique keys and keep them ready.
  - Pros: There will be no collision, extremely fast.
  - Cons: Complicated, single point of failure, can be avoided with a backup server, expensive. Will need some space to keep already generated keys.

# Other things to consider:
- Data partitioning:
- Cache:
- Load Balancer:
- Purging or DB cleanup:
- Telemetry:
- Different kinds of data that can be captured:
- Number of hits on a tinyURL
- Security and Permissions
  - Users can create private tinyURLs that allow particular set of users to access it. We will need a table for permissions.

